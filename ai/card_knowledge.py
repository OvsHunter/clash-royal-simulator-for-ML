"""Lightweight heuristic knowledge base for troop behaviour.

The user requested a JSON catalogue that lists **every** troop alongside
practical usage hints (for example *"drop Wizard behind a tank to clear
swarm"*).  ``data/card_behaviors.json`` is generated by
``tools/generate_card_behaviors.py`` and captures exactly that.  This module is
the runtime accessor for that catalogue and exposes helper utilities for the
rest of the AI stack.

The goal is not to hard-code a perfect bot; instead we provide structured
metadata that higher level systems (rule-based or learning agents) can consult
when making placement decisions.
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from functools import lru_cache
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence, Tuple


ROOT = Path(__file__).resolve().parents[1]
CATALOGUE_PATH = ROOT / "data" / "card_behaviors.json"


@dataclass(frozen=True)
class CardBehaviour:
    """Structured behaviour data for a single card."""

    name: str
    wiki_url: Optional[str]
    cost: float
    targets: Tuple[str, ...]
    flying: bool
    primary_roles: Tuple[str, ...]
    counter_tags: Tuple[str, ...]
    synergy_tags: Tuple[str, ...]
    placement_hints: Tuple[str, ...]
    elixir_profile: str

    @classmethod
    def from_dict(cls, data: Dict[str, object]) -> "CardBehaviour":
        return cls(
            name=str(data["name"]),
            wiki_url=data.get("wiki_url") or None,
            cost=float(data.get("cost", 0.0)),
            targets=tuple(str(t) for t in data.get("targets", [])),
            flying=bool(data.get("flying", False)),
            primary_roles=tuple(str(t) for t in data.get("primary_roles", [])),
            counter_tags=tuple(str(t) for t in data.get("counter_tags", [])),
            synergy_tags=tuple(str(t) for t in data.get("synergy_tags", [])),
            placement_hints=tuple(str(t) for t in data.get("placement_hints", [])),
            elixir_profile=str(data.get("elixir_profile", "cycle")),
        )


@lru_cache(maxsize=1)
def load_catalogue() -> Dict[str, CardBehaviour]:
    """Return the behaviour catalogue keyed by lower-case card name."""

    raw = json.loads(CATALOGUE_PATH.read_text())
    catalogue: Dict[str, CardBehaviour] = {}
    for item in raw:
        behaviour = CardBehaviour.from_dict(item)
        catalogue[behaviour.name.lower()] = behaviour
    return catalogue


def get_behaviour(card_name: str) -> Optional[CardBehaviour]:
    """Fetch behaviour metadata for ``card_name`` (case insensitive)."""

    if not card_name:
        return None
    return load_catalogue().get(card_name.lower())


def _score_behaviour(
    behaviour: CardBehaviour,
    threat_tags: Sequence[str],
    desired_roles: Sequence[str],
    desired_synergies: Sequence[str],
    max_cost: Optional[float],
) -> Tuple[float, List[str]]:
    score = 0.0
    reasons: List[str] = []

    threat_set = {t.lower() for t in threat_tags}
    role_set = {r.lower() for r in desired_roles}
    synergy_set = {s.lower() for s in desired_synergies}

    counter_matches = threat_set.intersection({t.lower() for t in behaviour.counter_tags})
    if counter_matches:
        score += 5.0 * len(counter_matches)
        reasons.append(f"answers {', '.join(sorted(counter_matches))}")

    role_matches = role_set.intersection({r.lower() for r in behaviour.primary_roles})
    if role_matches:
        score += 3.0 * len(role_matches)
        reasons.append(f"fills role {', '.join(sorted(role_matches))}")

    synergy_matches = synergy_set.intersection({s.lower() for s in behaviour.synergy_tags})
    if synergy_matches:
        score += 2.0 * len(synergy_matches)
        reasons.append(f"synergises via {', '.join(sorted(synergy_matches))}")

    if max_cost is not None and behaviour.cost > max_cost:
        score -= (behaviour.cost - max_cost)
        reasons.append("expensive for current elixir")

    return score, reasons


def recommend_cards(
    available_cards: Iterable[str],
    threat_tags: Sequence[str],
    desired_roles: Sequence[str] = (),
    desired_synergies: Sequence[str] = (),
    max_cost: Optional[float] = None,
    top_k: int = 3,
) -> List[Tuple[CardBehaviour, float, List[str]]]:
    """Rank ``available_cards`` against the supplied tactical requirements.

    Parameters
    ----------
    available_cards:
        Card names the agent can currently deploy.
    threat_tags:
        Labels describing what needs to be answered (e.g. ``["ground_swarm"]``).
    desired_roles:
        Roles we would like to field in support of an existing push
        (e.g. ``["ranged_support"]``).
    desired_synergies:
        Tags describing the offensive plan (for example ``["pair_with_support"]``).
    max_cost:
        Optional elixir ceiling for the recommendation.
    top_k:
        Number of recommendations to return.  Defaults to three.
    """

    catalogue = load_catalogue()
    scored: List[Tuple[CardBehaviour, float, List[str]]] = []

    for name in available_cards:
        behaviour = catalogue.get(name.lower())
        if not behaviour:
            continue
        score, reasons = _score_behaviour(
            behaviour,
            threat_tags=threat_tags,
            desired_roles=desired_roles,
            desired_synergies=desired_synergies,
            max_cost=max_cost,
        )
        # Slight preference for cheaper cards when scores tie.
        score -= behaviour.cost * 0.05
        scored.append((behaviour, score, reasons))

    scored.sort(key=lambda entry: entry[1], reverse=True)
    return scored[:top_k]


def describe(card_name: str) -> Optional[str]:
    """Return a human readable summary of how to play ``card_name``."""

    behaviour = get_behaviour(card_name)
    if not behaviour:
        return None
    hints = ", ".join(behaviour.placement_hints) or "flex placement"
    roles = ", ".join(behaviour.primary_roles) or "support"
    counters = ", ".join(behaviour.counter_tags) or "flex_counter"
    return (
        f"{behaviour.name} ({behaviour.cost} elixir) â€“ roles: {roles};"
        f" counters: {counters}; placement: {hints}."
    )

